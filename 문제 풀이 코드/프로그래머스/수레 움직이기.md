# ìˆ˜ë ˆ ì›€ì§ì´ê¸°

### ğŸš©êµ¬í•˜ëŠ” ê²ƒ

ì£¼ì–´ì§„ í¼ì¦ì„ í‘¸ëŠ”ë° í•„ìš”í•œ í„´ì˜ ìµœì†Ÿê°’

### âŒ¨ï¸ ì…ë ¥

- í¼ì¦íŒì˜ ì •ë³´ë¥¼ ë‚˜íƒ€ë‚´ëŠ” 2ì°¨ì› ì •ìˆ˜ ë°°ì—´ `maze`

### ğŸ–¨ï¸ ì¶œë ¥

- í¼ì¦ì„ í‘¸ëŠ”ë° í•„ìš”í•œ í„´ì˜ ìµœì†Ÿê°’

### ğŸš« ì œí•œ ì‚¬í•­

- 1 â‰¤Â `n, m` â‰¤ 4(`n`ì€ `maze`ì˜ ì„¸ë¡œ ê¸¸ì´, `m`ì€ `maze`ì˜ ê°€ë¡œ ê¸¸ì´)
- `maze[i][j]`ëŠ” 0,1,2,3,4,5 ì¤‘ í•˜ë‚˜ì˜ ê°’ì„ ê°€ì§

| `maze[i][j]` | ì˜ë¯¸                |
| ------------ | ------------------- |
| 0            | ë¹ˆì¹¸                |
| 1            | ë¹¨ê°„ ìˆ˜ë ˆì˜ ì‹œì‘ ì¹¸ |
| 2            | íŒŒë€ ìˆ˜ë ˆì˜ ì‹œì‘ ì¹¸ |
| 3            | ë¹¨ê°„ ìˆ˜ë ˆì˜ ë„ì°© ì¹¸ |
| 4            | íŒŒë€ ìˆ˜ë ˆì˜ ë„ì°© ì¹¸ |
| 5            | ë²½                  |

- ê° ìˆ˜ë ˆì˜ ì‹œì‘ ì¹¸ê³¼ ë„ì°© ì¹¸ì€ 1ê°œì”©ë§Œ ì¡´ì¬í•¨
- ê° í„´ë§ˆë‹¤ ë°˜ë“œì‹œ ëª¨ë“  ìˆ˜ë ˆë¥¼ ìˆ˜ë ˆ ë‚´ì—ì„œ í•œ ì¹¸ì”© ì›€ì§ì—¬ì•¼ í•¨
- ìˆ˜ë ˆëŠ” ìì‹ ì´ ë°©ë¬¸í–ˆë˜ ì¹¸ì— ë‹¤ì‹œ ë°©ë¬¸í•˜ì§€ ëª»í•¨
- ë„ì°© ì¹¸ì— ë„ë‹¬í•œ ìˆ˜ë ˆëŠ” ì›€ì§ì¼ ìˆ˜ ì—†ìŒ
- ë‘ ìˆ˜ë ˆëŠ” ë™ì‹œì— ê°™ì€ ì¹¸ì— ì¡´ì¬í•  ìˆ˜ ì—†ìŒ
- ìˆ˜ë ˆë¼ë¦¬ ì„œë¡œ ìë¦¬ë¥¼ ë°”ê¿€ ìˆ˜ ì—†ìŒ

### ğŸ— ì„¤ê³„

ë”°ì ¸ì•¼ í•  ê²½ìš°ì˜ ìˆ˜ê°€ ë§ë‹¤ë©´ ë°±íŠ¸ë˜í‚¹ì„ ì¨ì•¼í•œë‹¤.

ë˜í•œ ë°±íŠ¸ë˜í‚¹ í•¨ìˆ˜ ë‚´ì—ì„œ ì¢Œí‘œìƒì˜ 2ê°œì˜ ë¬¼ì²´ë¥¼ ì´ë™ì‹œì¼œì•¼ í•˜ê¸° ë•Œë¬¸ì— ì´ë™ ê°€ëŠ¥í•œ ê²½ë¡œë¥¼ ë¯¸ë¦¬ ì„ ì •í•´ì•¼ ì½”ë“œê°€ ê¹”ë”í•´ì§„ë‹¤.

### ğŸ’» ì½”ë“œ

```js
function solution(maze) {
  const [n, m] = [maze.length, maze[0].length];
  const moves = [
    [0, 1],
    [0, -1],
    [1, 0],
    [-1, 0],
  ];
  let redPos,
    bluePos,
    redDest,
    blueDest,
    answer = Infinity;
  const redVisit = new Array(n).fill().map(() => new Array(m).fill(0));
  const blueVisit = new Array(n).fill().map(() => new Array(m).fill(0));

  // í¼ì¦íŒ ìŠ¤ìº”
  maze.forEach((row, i) =>
    row.forEach((cell, j) => {
      // ì¶œë°œ ì¹¸
      if (cell === 1) [redPos, redVisit[i][j]] = [[i, j], 1];
      else if (cell === 2) [bluePos, blueVisit[i][j]] = [[i, j], 1];
      // ë„ì°© ì¹¸
      else if (cell === 3) redDest = [i, j];
      else if (cell === 4) blueDest = [i, j];
      // ë²½
      else if (cell === 5) [redVisit[i][j], blueVisit[i][j]] = [1, 1];
    })
  );

  // ìœ íš¨í•œ ì´ë™ ê²½ë¡œ ì°¾ê¸°
  const getValidMoves = (x, y, isRed) => {
    const visited = isRed ? redVisit : blueVisit;
    const validMoves = [];

    for (const [dx, dy] of moves) {
      const [nx, ny] = [x + dx, y + dy];

      if (nx >= 0 && nx < n && ny >= 0 && ny < m && !visited[nx][ny]) {
        validMoves.push([nx, ny]);
      }
    }

    return validMoves;
  };

  const backTracking = ([rx, ry], [bx, by], count) => {
    if (
      rx === redDest[0] &&
      ry === redDest[1] &&
      bx === blueDest[0] &&
      by === blueDest[1]
    ) {
      answer = Math.min(answer, count);
      return;
    }

    // ê° ìˆ˜ë ˆê°€ ë„ì°©ì¹¸ì— ë„ì°©í•œ ê²½ìš° ë„ì°©ì¹¸ì˜ ì¢Œí‘œë§Œ ë°˜í™˜
    const redMoves =
      rx === redDest[0] && ry === redDest[1]
        ? [[rx, ry]]
        : getValidMoves(rx, ry, true);

    const blueMoves =
      bx === blueDest[0] && by === blueDest[1]
        ? [[bx, by]]
        : getValidMoves(bx, by);

    for (const [rnx, rny] of redMoves) {
      for (const [bnx, bny] of blueMoves) {
        // êµì°¨ ì´ë™ ë° ë™ì¼ ìœ„ì¹˜ ì´ë™ ì œì™¸
        if (
          !(rnx === bx && rny === by && bnx === rx && bny === ry) &&
          !(rnx === bnx && rny === bny)
        ) {
          redVisit[rnx][rny] = 1;
          blueVisit[bnx][bny] = 1;
          backTracking([rnx, rny], [bnx, bny], count + 1);
          redVisit[rnx][rny] = 0;
          blueVisit[bnx][bny] = 0;
        }
      }
    }
  };

  backTracking(redPos, bluePos, 0);
  return answer === Infinity ? 0 : answer;
}
```
